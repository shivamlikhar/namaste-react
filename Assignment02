Assisment -02:
â— - What is `NPM`?
NPM (Package Manager) is the default package manager for Node.js. It is used to install, manage, and share JavaScript packages (libraries, frameworks, and tools).
Key Features of NPM: 
1. Package Management ğŸ“¦
-----------------
Allows you to install, update, and remove JavaScript libraries or tools.
Example: npm install parce -  installs the parce library.

2. Dependency Management ğŸ”„
---------------------
Keeps track of project dependencies in a package.json file.
Example: When installing a package, NPM updates package.json and package-lock.json.

3. Version Control ğŸ“Œ
----------------
Ensures projects use compatible versions of packages.
Example: You can install specific package versions using npm install react@18.2.0.

4. Script Running ğŸš€
---------------
Automates tasks using npm scripts inside package.json.
Example: npm run build can trigger a build process.

5. Global and Local Packages ğŸŒ
-------------------------
Local installation: Installed inside a project folder (node_modules).
Global installation: Available system-wide using npm install -g package-name.

Common NPM Commands
---------------------------------------------------------------
Command                     | Description
---------------------------------------------------------------
npm init                    | Initializes a new Node.js project and creates package.json.
npm install <package>       | Installs a package locally.
npm install -g <package>    | Installs a package globally.
npm update <package>        | Updates a package to its latest version.
npm uninstall <package>     | Removes a package from the project.
npm list                    | Lists installed packages.
npm run <script>            | Runs a script defined in package.json.
---------------------------------------------------------------

â— - What is `Parcel/Webpack`? Why do we need it?
Parcel and Webpack are module bundlers used in web development to bundle, optimize, and manage JavaScript, CSS, HTML, and other assets. They help improve performance, reduce file size, and ensure compatibility across different browsers.


ğŸ“¦ What is Parcel and Webpack? Why Do We Need Them?
Parcel and Webpack are module bundlers used in web development to bundle, optimize, and manage JavaScript, CSS, HTML, and other assets. They help improve performance, reduce file size, and ensure compatibility across different browsers.

ğŸ” Why Do We Need a Bundler?
Modern web applications use multiple JavaScript files, CSS styles, images, and other assets. Without a bundler, managing dependencies and optimizing the performance of a web application would be difficult.

Problems Without a Bundler:
ğŸš€ Too many HTTP requests â†’ Slows down performance.
âš ï¸ Global scope conflicts â†’ Multiple scripts can interfere with each other.
ğŸ“¦ No module system support â†’ ES6 modules and CommonJS need to be bundled.
ğŸ”„ No automatic optimizations â†’ No minification, tree shaking, or lazy loading.
ğŸ­ Difficult asset management â†’ Images, fonts, and CSS need proper handling.

What is Webpack?
Webpack is a powerful module bundler that processes and optimizes JavaScript, CSS, HTML, and assets for production. It helps to bundle multiple files into fewer optimized files.

âš¡ Key Features of Webpack
âœ… Module bundling â†’ Bundles JS, CSS, and other files together.
âœ… Code splitting â†’ Loads only necessary code using lazy loading.
âœ… Tree shaking â†’ Removes unused JavaScript code.
âœ… Loaders & Plugins â†’ Transforms files (e.g., Babel for ES6+).
âœ… Hot Module Replacement (HMR) â†’ Updates code without refreshing the page.

ğŸ“Œ How Webpack Works
1.Takes an entry point (e.g., index.js).
2.Processes all dependencies (JS, CSS, images).
3.Uses Loaders to transform files (e.g., Babel for ES6).
4.Uses Plugins to optimize assets.
5.Generates a final bundled output (bundle.js).

ğŸ“Œ What is Parcel?
Parcel is a zero-configuration bundler that automatically handles JavaScript, CSS, HTML, and assets without requiring a config file (unlike Webpack).
âš¡ Key Features of Parcel
âœ… Zero-config setup â†’ No need for webpack.config.js.
âœ… Faster builds â†’ Uses multi-core processing.
âœ… Built-in HMR â†’ Updates code live, without page reloads.
âœ… Automatic code splitting â†’ Loads only required JS.
âœ… Tree shaking & minification â†’ Removes unused code.

ğŸ“Œ How Parcel Works
Takes an entry file (index.html or index.js).
Automatically detects dependencies.
Optimizes and bundles everything (JS, CSS, images).
Outputs an optimized build.

â— -What is `.parcel-cache`
The .parcel-cache folder is a temporary cache directory created by Parcel to store processed files and speed up subsequent builds.

ğŸš€ Why Does Parcel Use .parcel-cache?
Parcel is designed to be fast, and rebuilding everything from scratch every time would be inefficient. Instead, it uses caching to reuse previously processed files, reducing build times significantly.

â— -What is `npx` ?
npx (Node Package eXecute) is a command-line tool that comes with Node.js (starting from npm v5.2+) and is used to execute Node.js packages without globally installing them.

â— - What is difference between `dependencies` vs `devDependencies`
When managing a Node.js or frontend project with npm or yarn, youâ€™ll see two types of dependencies in package.json:

Type  		| Purpose
---------------------------------------------------------------------------------------
dependencies	| Required for the app to run in production
devDependencies	| Only needed for development, testing, and building
---------------------------------------------------------------------------------------

â— - What is Tree Shaking?
Tree Shaking is an optimization technique used in JavaScript bundlers (like Webpack, Rollup, Parcel) to remove unused code (dead code) from the final bundle. This helps reduce file size and improve app performance.

â— - What is Hot Module Replacement?
Hot Module Replacement (HMR) is a feature in modern JavaScript bundlers (like Webpack, Vite, Parcel) that allows updating modules in a running application without a full page reload.

ğŸ”¹ Why is this useful?

Faster development ğŸš€ (No need to refresh manually).
Preserves application state ğŸ”„ (No loss of UI state, form inputs, etc.).
Instant updates âš¡ (Only changed modules reload, reducing downtime).
ğŸ“Œ How Does HMR Work?
You edit a file (e.g., App.js in React).
The bundler detects the change and compiles only the modified module.
The new module replaces the old one without refreshing the browser.
The app keeps its state while applying the updates.

â— - List down your favourite 5 superpowers of Parcel and describe any 3 of them in your
own words.
Parcel is a zero-config bundler that makes web development fast, simple, and efficient. Here are my top 5 favorite superpowers of Parcel:

1ï¸âƒ£ ğŸš€ Zero Configuration (Auto Magic ğŸ”®)
2ï¸âƒ£ âš¡ Super Fast Compilation (Multi-Core Processing)
3ï¸âƒ£ ğŸ”¥ Built-in Hot Module Replacement (HMR)
4ï¸âƒ£ ğŸ“¦ Tree Shaking & Code Splitting
5ï¸âƒ£ âœ… Out-of-the-Box Support for Multiple Languages (JS, TS, SCSS, JSX, etc.)

1ï¸âƒ£ ğŸš€ Zero Configuration (Auto Magic ğŸ”®)
Parcel works out of the box with zero configuration. Unlike Webpack, you donâ€™t need a webpack.config.js file or extra plugins.

ğŸ’¡ How it works:

Just install Parcel and run your app.
Parcel automatically detects dependencies and optimizes the build.
It even auto-installs missing dependencies (like Babel or PostCSS).

ğŸ“Œ Why is this cool?

No need to spend hours configuring Webpack.
Saves time for developers.
2ï¸âƒ£ âš¡ Super Fast Compilation (Multi-Core Processing)
Parcel is blazing fast âš¡ because it uses multi-core processing and caching.

ğŸ’¡ Why does this matter?

Traditional bundlers process files one at a time â†’ slow.
Parcel processes files in parallel â†’ much faster builds.
Uses caching to avoid unnecessary recompilation.
âœ… Example:

First build: 5 seconds
Rebuild with cache: 0.5 seconds ğŸ˜²
ğŸ“Œ Why is this cool?

Faster development = happier developers.
Saves time in large projects.
âœ… Out-of-the-Box Support for Multiple Languages
Parcel supports JavaScript, TypeScript, SCSS, LESS, JSX, Vue, Svelte, Rust, and more without extra configuration.

âœ… Example:

Write .ts, .scss, or .vue files without installing extra loaders.
Parcel automatically compiles and bundles them.
ğŸ“Œ Why is this cool?

No need to install plugins like Babel, PostCSS, or TypeScript loaders.
Everything just works automatically.

â— - What is the difference between `package.json` and `package-lock.json`?
Both package.json and package-lock.json are essential files in a Node.js project for managing dependencies, but they serve different purposes.
1ï¸âƒ£ package.json ğŸ“¦
Purpose: Defines the projectâ€™s metadata, scripts, and dependencies.

âœ… Key Features:

Lists the dependencies with version ranges (e.g., ^1.2.3 or ~1.2.3).
Includes project metadata (name, version, description).
Defines scripts (e.g., start, build, test).
Specifies engines (Node.js version requirements).

2ï¸âƒ£ package-lock.json ğŸ”’
Purpose: Locks the exact versions of installed dependencies for consistency.

âœ… Key Features:

Records the exact versions of all dependencies and sub-dependencies.
Prevents unexpected version updates when running npm install on different machines.
Speeds up installations by using a cached structure.
Ensures everyone in a team gets the same dependencies.
ğŸ“Š Quick Comparison Table

Feature                     | package.json ğŸ“¦                     | package-lock.json ğŸ”’
----------------------------|----------------------------------   |---------------------------------
Purpose                     | Defines dependencies & project info | Locks exact versions of dependencies
Versioning                  | Uses semantic versioning (^ or ~)   | Stores exact versions
Tracks sub-dependencies?    | âŒ No                              | âœ… Yes
Affects installations?      | âœ… Yes                             | âœ… Yes, ensures consistency
Should be committed to Git? | âœ… Yes                             | âœ… Yes (to lock dependencies)


â— - Why should I not modify `package-lock.json`?
The package-lock.json file is automatically generated and managed by NPM. Modifying it manually can cause issues in dependency management and lead to inconsistencies. 

